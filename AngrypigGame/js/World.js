/*
 * World Controller Class
 * 
 *   Manage RigidBodies in a box2D world
 *   
 * 		suffixes _el are jQuery DOM elements to be controlled
 * 		suffixes _mdl are Box2D model elements to be controlled
 * 
 * 	
 * 
 * Copyright 2014, VFS.  All Rights Reserved.
 */

var DEG_2_RAD = Math.PI / 180; 	// CONSTANT to Multiply by to convert degrees to radians.
var RAD_2_DEG = 180 / Math.PI; 	// CONSTANT to Multiply by to convert radians to degrees.
var TWO_PI = Math.PI * 2; 		// 360 degrees in radians.

// Some global stuff we need
// Shorthand "imports"
var b2Vec2 = Box2D.Common.Math.b2Vec2;
var b2BodyDef = Box2D.Dynamics.b2BodyDef;
var b2AABB = Box2D.Collision.b2AABB;
var b2Body = Box2D.Dynamics.b2Body;
var b2FixtureDef = Box2D.Dynamics.b2FixtureDef;
var b2Fixture = Box2D.Dynamics.b2Fixture;
var b2World = Box2D.Dynamics.b2World;
var b2MassData = Box2D.Collision.Shapes.b2MassData;
var b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape;
var b2CircleShape = Box2D.Collision.Shapes.b2CircleShape;
var b2DebugDraw = Box2D.Dynamics.b2DebugDraw;
var b2MouseJointDef =  Box2D.Dynamics.Joints.b2MouseJointDef;
var b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape;

var b2Listener = Box2D.Dynamics.b2ContactListener;


/*
 * The World
 */
World.SCALE = 20.0;  // number of pixels per meter in the physics sim
World.GRAVITY = 9.8; // The force of gravity

function World( domContainer_el ) {
	// Create the Box2D World with horizontal and vertical gravity vector(10 is close enough to 9.8)
    this.physics_mdl = new b2World( new b2Vec2(0, World.GRAVITY) ,true ); //allow sleep

    var w = domContainer_el.width();
    var h = domContainer_el.height();
    
    this.createBoundaries( w, h );
    
    //Add listeners for contact/collisions
    var listener = new b2Listener;

    /*
     * Don't create or destroy any physics entities in these event handlers, store the info to
     * manage in an update later.
     * 
     * The Contact object is generated by Box2D to contain the collision info
     * It also contains a method to get the two fixtures that collided
     * Use them to inspect the user data.
     * 
     * its key that the user data have info identifying the dom element so you can manipulate.
     * 
     */ 
    listener.BeginContact = function(contact) {
    	
    	/*if(contact.GetFixtureA().GetBody().eUserData.ball!=null)
    		{}*/var username = $("#textarea").val();
    			
		    		if(contact.GetFixtureB().GetBody().GetUserData().type=="ball"&&contact.GetFixtureA().GetBody().GetUserData().type=="enemy")
		    		{
		    			$("#gameboard").hide();	
						$("#toolbar").hide();	
						$("#winningcondition").html("You Win!"+"<br>"
													+"Congraduations!"+"<br>"
													+username+"<br>"													
													+"click screen to reload");
						$("#ending").show();
		    		}
		    		if(contact.GetFixtureA().GetBody().GetUserData().type=="ball"&&contact.GetFixtureB().GetBody().GetUserData().type=="enemy")
		    		{
		    			$("#gameboard").hide();	
						$("#toolbar").hide();	
						$("#winningcondition").html("You Win!"+"<br>"
													+"Congraduations!"+"<br>"
													+username+"<br>"													
													+"click screen to reload");
						$("#ending").show();
		    		}
		    		
    		
    	//console.log(contact.GetFixtureB().GetBody().GetUserData().type);
    	// This is called when two fixtures begin to overlap. 
    	//

		
		//Penguin and enemy

    }

    listener.EndContact = function(contact) {
    	//
    	// console.log(contact.GetFixtureA().GetBody().GetUserData());
    	//
    	// This is called when two fixtures cease to overlap. 
    	//
    }

    listener.PreSolve = function(contact, oldManifold) {
    	//
    	// PreSolve
    	//
    	// This is called after collision detection, but before collision resolution. 
    	// This gives you a chance to disable the contact based on the current configuration.
    	//
    }

    listener.PostSolve = function(contact, impulse) {
    	//
    	// PostSolve
    	//
    	// The post solve event is where you can gather collision impulse results. If you donï¿½t care about the impulses, 
    	// you should probably just implement the pre-solve event.
    	// 
    	//if (contact.GetFixtureA().GetBody().GetUserData() == 'ball' || contact.GetFixtureB().GetBody().GetUserData() == 'ball') {
    	//	
		//    console.log(world.ball.impulse);
    	//}
    }


    this.physics_mdl.SetContactListener(listener);
};



// Class prototypes - methods which can be applied only to objects of the class
World.prototype.getModel = function() {

	return this.physics_mdl;
};


World.prototype.createBoundaries = function( screenW, screenH ) {
	
    // Create the ground fixture definition
    var fixDef = new b2FixtureDef;
    fixDef.shape = new b2PolygonShape;    
    fixDef.density = 2.0;
    fixDef.friction = 0.9;
    fixDef.restitution = 0.8;
   
    // Create the body definition
    var bodyDef = new b2BodyDef;
    bodyDef.type = b2Body.b2_staticBody; 
    
    
    // change the ground shape, and connect it with a fixture to the body
    bodyDef.position.x = screenW / 2 / World.SCALE;
    bodyDef.position.y = screenH / World.SCALE;   
    
    fixDef.shape.SetAsBox( screenW / World.SCALE, 1.0 / World.SCALE );
    var top=this.physics_mdl.CreateBody( bodyDef );
    top.CreateFixture( fixDef );
    top.m_userData = { 
  	      domObj:this.eElement
};
	

    
    bodyDef.position.x = screenW / 2 / World.SCALE;
    bodyDef.position.y = 0;   
    
    fixDef.shape.SetAsBox( screenW / World.SCALE, 1.0 / World.SCALE );
    var bot=this.physics_mdl.CreateBody( bodyDef );
    bot.CreateFixture( fixDef );
    bot.m_userData = { 
  	      domObj:this.eElement

};

    
    
    // Left Edge
	// The edge is positioned at the left most i.e. x = 0 and y = screenH/2 as the center. width is 1 and height = screenH
    bodyDef.position.x = 0; // need to add offset from screen edge based on current left attrib of game-area
    bodyDef.position.y = screenH / 2 / World.SCALE;
	
    fixDef.shape.SetAsBox( 1.0 / World.SCALE , screenH / World.SCALE );
    var left=this.physics_mdl.CreateBody( bodyDef );
    left.CreateFixture( fixDef );
    left.m_userData = { 
  	      domObj:this.eElement

};


	
	
	// Right Edge 
	// same as left edge, positioned on the rightmost end of our canvas
	bodyDef.position.x = screenW / World.SCALE;
	bodyDef.position.y = screenH / 2 / World.SCALE;
    var right=this.physics_mdl.CreateBody( bodyDef );
    right.CreateFixture( fixDef );
    right.m_userData = { 
  	      domObj:this.eElement

};

};


World.prototype.update = function() {  	

	this.physics_mdl.Step( 1/60, 10, 10 ); // frame-rate, velocity iterations, position iterations
};	

World.prototype.render = function() {

};


